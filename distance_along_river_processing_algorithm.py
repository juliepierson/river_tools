# -*- coding: utf-8 -*-

"""
/***************************************************************************
 DistanceAlongRiver
                                 A QGIS plugin
 Calculate distances between pair of points by projecting them on a river axis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-30
        copyright            : (C) 2021 by J. Pierson, UMR 6554 LETG, CNRS
        email                : julie.pierson@univ-brest.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'J. Pierson, UMR 6554 LETG, CNRS'
__date__ = '2021-03-30'
__copyright__ = '(C) 2021 by J. Pierson, UMR 6554 LETG, CNRS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsMessageLog,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterDistance,
                       QgsProcessingParameterVectorDestination,
                       QgsWkbTypes,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFolderDestination,
                       QgsVectorLayer,
                       QgsProject)
import processing
import pandas as pd


class DistanceAlongRiverAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT1 = 'INPUT1'
    IDFIELD1 = 'IDFIELD1'
    INPUT2 = 'INPUT2'
    IDFIELD2 = 'IDFIELD2'
    RIVER = 'RIVER'
    PROJECTED_POINTS = 'PROJECTED_POINTS'
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'
    CENTERLINE_OUTPUT = 'CENTERLINE_OUTPUT'
    PROJECTED1 = 'PROJECTED1'
    PROJECTED2 = 'PROJECTED2'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # 1st input point layer
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT1,
                self.tr('First input point layer'),
                [QgsProcessing.TypeVectorPoint ]
            )
        )
            
        # id field for 1st input layer
        self.addParameter(
            QgsProcessingParameterField(
                self.IDFIELD1,
                self.tr('ID field for first input layer'),
                '',
                self.INPUT1
            )
        )
            
        # 2nd input point layer
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT2,
                self.tr('Second input point layer'),
                [QgsProcessing.TypeVectorPoint ]
            )
        )
            
        # id field for 2nd input layer
        self.addParameter(
            QgsProcessingParameterField(
                self.IDFIELD2,
                self.tr('ID field for second input layer'),
                '',
                self.INPUT2
            )
        )
            
        # input river layer
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.RIVER,
                self.tr('Input river layer, if polygon layer its centerline will be calculated'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )
            
        # output folder for CSV
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_FOLDER, 
                self.tr('Output folder for CSV file with distances'),
                None, True))
        
        # ouput centerline layer, created if input is polygon
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.CENTERLINE_OUTPUT,
                self.tr('Output centerline layer, can be created if input layer is polygon'),
                optional=True
                #QgsProcessing.TypeVectorPolygon
            )
        )
            
        # ouput projected layer 1
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.PROJECTED1,
                self.tr('Output projected point layer 1'),
                optional=True
                #QgsProcessing.TypeVectorPolygon
            )
        )
            
        # ouput projected layer 2
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.PROJECTED2,
                self.tr('Output projected point layer 2'),
                optional=True
                #QgsProcessing.TypeVectorPolygon
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        
        # Retrieve inputs
        input1 = self.parameterAsVectorLayer(parameters, self.INPUT1, context)
        idfield1 = self.parameterAsString(parameters, self.IDFIELD1, context)
        input2 = self.parameterAsVectorLayer(parameters, self.INPUT2, context)
        idfield2 = self.parameterAsString(parameters, self.IDFIELD2, context)
        river = self.parameterAsVectorLayer(parameters, self.RIVER, context)
        output_folder = self.parameterAsFile(parameters, self.OUTPUT_FOLDER, context)
       
        # if river layer is polygon, calculate the centerline for the input layer        
        if river.geometryType() == QgsWkbTypes.PolygonGeometry :
            centerline_output = self.createCenterline(river, parameters, context, feedback)
            centerline = centerline_output['output']
        # if input layer is line, it is considered as centerline
        if river.geometryType() == QgsWkbTypes.LineGeometry:
            centerline = river
            
        # if no polygon layer provided
        if river.geometryType() == QgsWkbTypes.LineGeometry:
            # if centerline is composed of multiple lines, merge them
            features = centerline.getFeatures()
            nb_features = sum(1 for _ in features)
            if nb_features > 1:
                centerline = self.mergeLines(centerline, context, feedback)
              
        # create projected point layer for 1st input layer
        projected1 = self.projectPoints(input1, idfield1, centerline, self.PROJECTED1, parameters, context, feedback)
        # create projected point layer for 2nd input layer
        projected2 = self.projectPoints(input2, idfield2, centerline, self.PROJECTED2, parameters, context, feedback)
        
        # create dataframe with distances between pair of points
        distance_dataframe = self.createDistanceDataframe(output_folder, projected1, projected2, idfield1, idfield2, context, feedback)
        
        # write dataframe to CSV file
        #self.createCsv(output_folder, distance_dataframe, context, feedback)
        
        # Return the results of the algorithm : projected points layers, centerline layer if wanted
        try:
            return {self.PROJECTED1:projected1, self.PROJECTED2:projected2, self.CENTERLINE_OUTPUT:centerline_output['output']}
        except NameError:
            return {self.PROJECTED1:projected1, self.PROJECTED2:projected2}
    
    def createCenterline(self, polygon, parameters, context, feedback):
        message = 'Creating  centerline with grass voronoi.skeleton algorithm...'
        feedback.pushInfo(QCoreApplication.translate('Segmentation Boxes', message))
        # voronoi.skeleton parameters
        skeleton_param = {'input' : polygon,
                  'smoothness' : 0.1,
                  'thin' : -1,
                  'output' : parameters[self.CENTERLINE_OUTPUT]} # to output this layer in QGIS as well
        # run voronoi.skeleton
        skeleton_result = processing.run("grass7:v.voronoi.skeleton", skeleton_param, is_child_algorithm=True, context=context, feedback=feedback)
        #centerline = skeleton_result['output']
        # Check for cancelation
        if feedback.isCanceled():
            return {}
        # return centerline
        return skeleton_result
    
    def mergeLines(self, line, context, feedback):
        message = 'Grouping lines with dissolve algorithm...'
        feedback.pushInfo(QCoreApplication.translate('Segmentation Boxes', message))
        # dissolve parameters
        dissolve_param = {'INPUT' : line,
                  'FIELD' : None,
                  #'OUTPUT' : parameters[self.OUTPUT]} # to output this layer in QGIS as well
                  'OUTPUT' : 'dissolve'}
        # run dissolve
        dissolve_result = processing.run("native:dissolve", dissolve_param, is_child_algorithm=True, context=context, feedback=feedback)
        dissolve_layer = dissolve_result['OUTPUT']
        # Check for cancelation
        if feedback.isCanceled():
            return {}
        # return dissolved layer
        return dissolve_layer
    
    def runSqlQuery(self, layer_list, field_list, query, context, feedback):
        pass
    
    def projectPoints(self, point_layer, point_id_field, line_layer, projected, parameters, context, feedback):
        message = 'Executing SQL query to project points on river centerline...'
        feedback.pushInfo(QCoreApplication.translate('Distance along river', message))
        # if layer is loaded, get its name, else gets it source = full path
        if len(QgsProject.instance().mapLayersByName(point_layer.name())) != 0:
            call_point_layer = point_layer.name()
        else:
            call_point_layer = point_layer.source()
        if len(QgsProject.instance().mapLayersByName(line_layer.name())) != 0:
            call_line_layer = line_layer.name()
        else:
            call_line_layer = line_layer.source()
        # SQL query to get intersection between 1/ shortest lines between points and river centerline and 2/ river centerline
        query = f"""SELECT st_endpoint(ST_ShortestLine(p.geometry, l.geometry)) as geometry,
                    p.{point_id_field},
                    ROUND(ST_Length(ST_ShortestLine(p.geometry, l.geometry)), 6) AS distance
                FROM "{call_point_layer}" AS p, "{call_line_layer}" AS l"""
        # executesql parameters
        executesql_param = {'INPUT_DATASOURCES' : [call_point_layer, call_line_layer],
                            'INPUT_QUERY' : query,
                            'OUTPUT' : parameters[projected]} # to output this layer in QGIS as well
        # run executesql algorithm
        executesql_result = processing.run("qgis:executesql", executesql_param, is_child_algorithm=True, context=context, feedback=feedback)
        executesql_layer = executesql_result['OUTPUT']
        # Check for cancelation
        if feedback.isCanceled():
            return {}
        # return projected points layer
        return executesql_layer
    
    def createDistanceDataframe(self, input1, input2, projected1, projected2, idfield1, idfield2, context, feedback):
        message = 'Calculating distances between orginal points...'
        feedback.pushInfo(QCoreApplication.translate('Distance along river', message))
        # if layer is loaded, get its name, else gets it source = full path
        if len(QgsProject.instance().mapLayersByName(input1.name())) != 0:
            call_input1 = input1.name()
        else:
            call_input1 = input1.source()
        if len(QgsProject.instance().mapLayersByName(input2.name())) != 0:
            call_input2 = input2.name()
        else:
            call_input2 = input2.source()
        # create table with distances between original points
        query = f"""SELECT p1.{idfield1} as ID1, p2.{idfield2} as ID2, ST_Distance(p1.geometry, p2.geometry) as distance 
                        FROM "{call_input1}" as p1 LEFT JOIN "{call_input2}" as p2 
                        ON p1.{idfield1} = p2.{idfield2}
                    UNION
                    SELECT p1.{idfield1} as ID1, p2.{idfield2} as ID2, ST_Distance(p1.geometry, p2.geometry) as distance 
                        FROM "{call_input2}" as p2 LEFT JOIN "{call_input1}" as p1 
                        ON p1.{idfield1} = p2.{idfield2};"""
        executesql_param = {'INPUT_DATASOURCES' : [input1, input2],
                            'INPUT_QUERY' : query,
                            'OUTPUT' : "distances1"}
        executesql_result = processing.run("qgis:executesql", executesql_param, is_child_algorithm=True, context=context, feedback=feedback)
        distances1 = executesql_result['OUTPUT']
        # convert table to python dictionary
        fields = distances1.fields()
        dic = dict((field.name(), []) for field in fields)
        features = distances1.getfeatures()
        for feature in features:
            for field in fields:
                dic[field.name()].append(feature[field.name()])
        # convert dictionary to pandas dataframe
        df = pd.DataFrame(data=dic)
        # create table with distances between projected points
        
        # join the 2 tables into one table
        
        # convert table to dataframe
        
        # round distances
    
    def createCsv(self, output_folder, dataframe, context, feedback):
        pass
    

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Distance along river'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return DistanceAlongRiverAlgorithm()
